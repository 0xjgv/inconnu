
{
  "status": "ok",
  "issue": {
    "id": "24809ee1-7b41-4352-b33a-4c2c0fe20fcd",
    "scan_id": "c9a5b7a3-4470-427b-9b1f-b1149b72f3f0",
    "status": "open",
    "urgency": "LO",
    "created_at": "2025-07-11T15:07:25.218Z",
    "classification": {
      "id": "CWE-625",
      "name": "Permissive Regular Expression",
      "description": "The product uses a regular expression that does not sufficiently restrict the set of allowed values."
    },
    "location": {
      "file": {
        "name": "patterns.py",
        "language": "python",
        "path": "inconnu/nlp/patterns.py"
      },
      "line_number": 54,
      "project": {
        "name": "build",
        "branch": "main",
        "git_sha": "7257bc0f80f9b5656bf6d1309fcd2454affc733d"
      }
    },
    "details": {
      "explanation": "The code uses a regex pattern that doesn't limit allowed values well, letting unexpected or malicious input through. This can cause issues when processing text with bullets.<br><br>- \"BULLETS_PATTERN\" joins all bullet types, but the regex \"UNICODE_BULLETS_RE\" doesn't fully restrict sequences, allowing unwanted inputs.<br>- The negative lookahead \"(?!{BULLETS_PATTERN})\" aims to prevent repeated bullets but can fail, letting attackers sneak in bad input.<br>- If these bullets are used in sensitive text processing, malicious or malformed input could disrupt parsing or cause logic errors."
    },
    "auto_triage": {
      "false_positive_detection": {
        "status": "valid",
        "reasoning": "The code uses <code>\"|\".join(UNICODE_BULLETS)</code> directly in regex patterns without escaping metacharacters like <code>*</code> and <code>-</code>, which can alter the intended regex behavior. This can cause unintended matching or regex injection if the bullet list is ever extended or modified, as seen in lines <code>54</code> and <code>55</code> where <code>BULLETS_PATTERN</code> is interpolated directly into regexes. The absence of escaping means that regex control characters can change the pattern meaning, making this a valid security issue."
      }
    },
    "auto_fix_suggestion": {
      "id": "6c87b715-1514-449d-88d0-5e64164c5ca3",
      "status": "fix_available",
      "patch": {
        "diff": "diff --git a/inconnu/nlp/patterns.py b/inconnu/nlp/patterns.py\nindex ed4774b..7dad5f3 100644\n--- a/inconnu/nlp/patterns.py\n+++ b/inconnu/nlp/patterns.py\n@@ -51,7 +51,7 @@ UNICODE_BULLETS: Final[List[str]] = [\n     \"\\x95\",\n     \"·\",\n ]\n-BULLETS_PATTERN = \"|\".join(UNICODE_BULLETS)\n+BULLETS_PATTERN = \"|\".join(re.escape(b) for b in UNICODE_BULLETS)\n UNICODE_BULLETS_RE = re.compile(f\"(?:{BULLETS_PATTERN})(?!{BULLETS_PATTERN})\")\n # zero-width positive lookahead so bullet characters will not be removed when using .split()\n UNICODE_BULLETS_RE_0W = re.compile(f\"(?={BULLETS_PATTERN})(?<!{BULLETS_PATTERN})\")\n",
        "explanation": "The fix escapes all bullet characters in the regex pattern using <code>re.escape()</code>, preventing special regex characters from altering the pattern’s behavior and thus restricting allowed values as intended.\nThe original <code>BULLETS_PATTERN = \"|\".join(UNICODE_BULLETS)</code> directly joined characters including special regex symbols, risking unintended matches.\n    By changing to <code>BULLETS_PATTERN = \"|\".join(re.escape(b) for b in UNICODE_BULLETS)</code>, each bullet is escaped, ensuring it is treated as a literal character in the regex.\n    This eliminates the possibility of bullets being interpreted as regex operators, closing the loophole that allowed invalid inputs.\n    The compiled regex <code>UNICODE_BULLETS_RE</code> now safely matches only the specified bullet characters without accidental pattern expansion."
      },
      "full_code": null
    }
  }
}
